# GraphQL _SIMPLE_ hierarchy PoC

interface Named {
  name: String!
}

interface Animal {
  animalSpecificStuff: String!
}

type Chicken implements Node & Named & Animal {
  id: ID!
  name: String!
  animalSpecificStuff: String!

}

type Horse implements Node & Named & Animal {
  id: ID!
  name: String!
  animalSpecificStuff: String!

}

type Person implements Node & Named & Animal {
  id: ID!
  name: String!
  animalSpecificStuff: String!

}

# We use the union + interface trick to allow client to discover what occupants to expect, while still being
# able to handle new occupants over time by Interface that are expected on occupants
union ZoneOccupants = Person | Chicken | Horse

interface Zone {
  occupants: [ZoneOccupants]!
}

type Barn implements Node & Named & Zone {
  id: ID!
  name: String!
  occupants: [ZoneOccupants]!

}

type Coop implements Node & Named & Zone {
  id: ID!
  name: String!
  occupants: [ZoneOccupants]!

}

type Field implements Node & Named & Zone {
  id: ID!
  name: String!
  occupants: [ZoneOccupants]!

}

type FarmHouse implements Node & Named & Zone {
  id: ID!
  name: String!
  occupants: [ZoneOccupants]!

}

type Farm implements Node & Named {
  id: ID!
  name: String!

}

type QueryFarmResult {
  data: Farm
  errors: [String!] # TODO - placeholder for error communication - instead, could return the union of possible errors
}

# Farm has zones (eg. House, Barn, Field(s)), Barn has Animal(s), Field has Animal(s), House has people

# TODO: Return a Farm with it's zones...  sort out how client can see the aggregate of the properties 
# it wants from the various interfaces

# TODO: PoC the multi-level deep hierarchy in naive fashion first (i.e. no fancy paging, etc...)

# TODO: Adjust for paging
